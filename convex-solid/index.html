<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game of Life - Server Tick</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #f3f4f6;
        font-family: "Courier New", monospace;
        overflow: hidden;
      }

      #hud {
        position: absolute;
        top: 16px;
        left: 16px;
        z-index: 10;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(4px);
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        font-size: 14px;
      }

      #gameCanvas {
        cursor: pointer;
        display: block;
      }

      #gameCanvas.panning {
        cursor: grabbing;
      }

      #gameCanvas.pan-ready {
        cursor: grab;
      }

      .hud-title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 8px;
      }

      .hud-row {
        margin: 4px 0;
      }

      .controls {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #e5e7eb;
        font-size: 12px;
        color: #6b7280;
      }

      .shapes-section {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #e5e7eb;
      }

      .shapes-title {
        font-size: 12px;
        font-weight: bold;
        color: #374151;
        margin-bottom: 6px;
      }

      .shapes-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px;
      }

      .shape-button {
        background: #f3f4f6;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        padding: 4px 6px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.15s;
        text-align: center;
        color: #374151;
      }

      .shape-button:hover {
        background: #e5e7eb;
        border-color: #9ca3af;
      }

      .shape-button.selected {
        background: #3b82f6;
        border-color: #2563eb;
        color: white;
      }
    </style>
  </head>
  <body>
    <div id="hud">
      <div class="hud-title">Game of Life - Server Tick</div>
      <div class="hud-row">Generation: <span id="generation">0</span></div>
      <div class="hud-row">Total Chunks: <span id="totalChunks">0</span></div>
      <div class="hud-row">Visible Cells: <span id="visibleCells">0</span></div>
      <div class="hud-row">Memory: <span id="memory">N/A</span></div>
      <div class="hud-row">FPS: <span id="fps">0</span></div>
      <div class="hud-row">Zoom: <span id="zoom">1.0</span>x</div>
      <div class="hud-row">
        Viewport: (<span id="viewportX">0</span>, <span id="viewportY">0</span>)
      </div>
      <div class="hud-row">Status: <span id="status">STOPPED</span></div>

      <div class="shapes-section">
        <div class="shapes-title">Place Shapes:</div>
        <div class="shapes-grid">
          <button class="shape-button selected" data-shape="draw">Draw</button>
          <button class="shape-button" data-shape="clear">Clear</button>
          <button class="shape-button" data-shape="glider">Glider</button>
          <button class="shape-button" data-shape="block">Block</button>
          <button class="shape-button" data-shape="blinker">Blinker</button>
          <button class="shape-button" data-shape="beacon">Beacon</button>
          <button class="shape-button" data-shape="toad">Toad</button>
          <button class="shape-button" data-shape="pulsar">Pulsar</button>
        </div>
      </div>

      <div class="controls">
        <div><strong>Draw mode:</strong> Click/drag to toggle cells</div>
        <div><strong>Shape mode:</strong> Click to place selected shape</div>
        <div>Shift + drag: pan viewport</div>
        <div>Mouse wheel: zoom</div>
        <div>WASD/arrows: pan</div>
        <div>Space: toggle simulation, C: clear</div>
      </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Convex Integration -->
    <script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
    <script>
      class ServerTickGameOfLife {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d");

          // Grid configuration
          this.CELL_SIZE = 20;
          this.CHUNK_SIZE = 64;

          // Local state (mirrors server state)
          this.chunks = new Map(); // Local cache of visible chunks
          this.generation = 0;
          this.isRunning = false;

          // Convex integration
          this.convexClient = null;
          this.isConnected = false;
          this.pendingChunkUpdates = new Map();
          this.syncInterval = null;

          // Viewport and zoom
          this.viewportX = 0;
          this.viewportY = 0;
          this.zoom = 1.0;
          this.minZoom = 0.1;
          this.maxZoom = 10.0;

          // Mouse interaction state
          this.isMouseDown = false;
          this.isPanning = false;
          this.isShiftPressed = false;
          this.lastToggledCell = "";
          this.dragStart = { x: 0, y: 0, viewportX: 0, viewportY: 0 };
          this.selectedShape = "draw";

          // Performance throttling
          this.lastDragUpdate = 0;
          this.DRAG_THROTTLE_MS = 16;

          // Performance monitoring
          this.frameCount = 0;
          this.lastFpsTime = performance.now();
          this.fps = 0;
          this.rafId = null;

          this.setupCanvas();
          this.setupEventListeners();
          this.initializeConvex();
          this.startPerformanceMonitoring();
          this.render();
        }

        setupCanvas() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          this.GRID_WIDTH = Math.floor(this.canvas.width / this.CELL_SIZE);
          this.GRID_HEIGHT = Math.floor(this.canvas.height / this.CELL_SIZE);
        }

        async initializeConvex() {
          try {
            while (typeof convex === "undefined") {
              await new Promise((resolve) => setTimeout(resolve, 100));
            }

            const CONVEX_URL = "https://trustworthy-gnu-78.convex.cloud";
            this.convexClient = new convex.ConvexClient(CONVEX_URL);
            this.isConnected = true;

            console.log("Connected to Convex");

            // Initialize game state if it doesn't exist
            await this.convexClient.mutation("gameOfLife:initializeGameState");

            // Subscribe to game state
            this.convexClient.onUpdate(
              "gameOfLife:getGameState",
              {},
              (gameState) => {
                if (gameState) {
                  this.generation = gameState.generation;
                  this.isRunning = gameState.isRunning;
                  this.updateHUD();
                }
              },
            );

            // Subscribe to visible chunks
            this.loadVisibleChunks();

            // Start periodic sync for chunk updates
            this.syncInterval = setInterval(() => {
              this.syncPendingChunks();
            }, 200);
          } catch (error) {
            console.error("Failed to initialize Convex:", error);
          }
        }

        loadVisibleChunks() {
          if (!this.isConnected) return;

          const effectiveCellSize = this.CELL_SIZE * this.zoom;
          const centerX = this.canvas.width / 2;
          const centerY = this.canvas.height / 2;

          const leftBound = this.viewportX - centerX / effectiveCellSize;
          const rightBound = this.viewportX + centerX / effectiveCellSize;
          const topBound = this.viewportY - centerY / effectiveCellSize;
          const bottomBound = this.viewportY + centerY / effectiveCellSize;

          const minChunkX = Math.floor(leftBound / this.CHUNK_SIZE) - 1;
          const maxChunkX = Math.floor(rightBound / this.CHUNK_SIZE) + 1;
          const minChunkY = Math.floor(topBound / this.CHUNK_SIZE) - 1;
          const maxChunkY = Math.floor(bottomBound / this.CHUNK_SIZE) + 1;

          this.convexClient.onUpdate(
            "gameOfLife:getChunks",
            {
              minChunkX,
              maxChunkX,
              minChunkY,
              maxChunkY,
            },
            (convexChunks) => {
              this.syncFromConvex(
                convexChunks,
                minChunkX,
                maxChunkX,
                minChunkY,
                maxChunkY,
              );
              this.render();
            },
          );
        }

        syncFromConvex(
          convexChunks,
          minChunkX,
          maxChunkX,
          minChunkY,
          maxChunkY,
        ) {
          // Clear local chunks in visible area
          for (let chunkX = minChunkX; chunkX <= maxChunkX; chunkX++) {
            for (let chunkY = minChunkY; chunkY <= maxChunkY; chunkY++) {
              const chunkKey = `${chunkX},${chunkY}`;
              this.chunks.delete(chunkKey);
            }
          }

          // Load chunks from Convex
          for (const convexChunk of convexChunks) {
            const chunkKey = `${convexChunk.chunkX},${convexChunk.chunkY}`;
            const cellSet = new Set(convexChunk.cells);
            this.chunks.set(chunkKey, cellSet);
          }
        }

        // Coordinate packing/unpacking (same as before)
        packCoords(x, y) {
          return ((x & 0xffff) << 16) | (y & 0xffff);
        }

        unpackCoords(packed) {
          let x = (packed >> 16) & 0xffff;
          let y = packed & 0xffff;

          if (x >= 0x8000) x -= 0x10000;
          if (y >= 0x8000) y -= 0x10000;

          return [x, y];
        }

        getChunkKey(worldX, worldY) {
          const chunkX = Math.floor(worldX / this.CHUNK_SIZE);
          const chunkY = Math.floor(worldY / this.CHUNK_SIZE);
          return `${chunkX},${chunkY}`;
        }

        getChunkCoords(worldX, worldY) {
          return {
            chunkX: Math.floor(worldX / this.CHUNK_SIZE),
            chunkY: Math.floor(worldY / this.CHUNK_SIZE),
            localX:
              ((worldX % this.CHUNK_SIZE) + this.CHUNK_SIZE) % this.CHUNK_SIZE,
            localY:
              ((worldY % this.CHUNK_SIZE) + this.CHUNK_SIZE) % this.CHUNK_SIZE,
          };
        }

        // Add cell locally and queue for sync
        addCell(worldX, worldY) {
          const chunkKey = this.getChunkKey(worldX, worldY);
          const { chunkX, chunkY, localX, localY } = this.getChunkCoords(
            worldX,
            worldY,
          );
          const packed = this.packCoords(localX, localY);

          if (!this.chunks.has(chunkKey)) {
            this.chunks.set(chunkKey, new Set());
          }
          this.chunks.get(chunkKey).add(packed);

          this.queueChunkUpdate(chunkX, chunkY);
        }

        removeCell(worldX, worldY) {
          const chunkKey = this.getChunkKey(worldX, worldY);
          const { chunkX, chunkY, localX, localY } = this.getChunkCoords(
            worldX,
            worldY,
          );
          const packed = this.packCoords(localX, localY);

          const chunk = this.chunks.get(chunkKey);
          if (chunk) {
            chunk.delete(packed);
            if (chunk.size === 0) {
              this.chunks.delete(chunkKey);
            }
            this.queueChunkUpdate(chunkX, chunkY);
          }
        }

        hasCell(worldX, worldY) {
          const chunkKey = this.getChunkKey(worldX, worldY);
          const { localX, localY } = this.getChunkCoords(worldX, worldY);
          const packed = this.packCoords(localX, localY);

          const chunk = this.chunks.get(chunkKey);
          return chunk ? chunk.has(packed) : false;
        }

        queueChunkUpdate(chunkX, chunkY) {
          if (!this.isConnected) return;

          const chunkKey = `${chunkX},${chunkY}`;
          const chunk = this.chunks.get(chunkKey);
          const cells = chunk ? Array.from(chunk) : [];

          this.pendingChunkUpdates.set(chunkKey, {
            chunkX,
            chunkY,
            cells,
          });
        }

        async syncPendingChunks() {
          if (!this.isConnected || this.pendingChunkUpdates.size === 0) return;

          try {
            const chunksToUpdate = Array.from(
              this.pendingChunkUpdates.values(),
            );
            this.pendingChunkUpdates.clear();

            await this.convexClient.mutation("gameOfLife:placeCells", {
              chunkUpdates: chunksToUpdate,
            });
          } catch (error) {
            console.error("Failed to sync chunks:", error);
          }
        }

        // Convert screen coordinates to world coordinates
        screenToWorld(screenX, screenY) {
          const effectiveCellSize = this.CELL_SIZE * this.zoom;
          const centerX = this.canvas.width / 2;
          const centerY = this.canvas.height / 2;

          const worldX = Math.floor(
            (screenX - centerX) / effectiveCellSize + this.viewportX,
          );
          const worldY = Math.floor(
            (screenY - centerY) / effectiveCellSize + this.viewportY,
          );

          return [worldX, worldY];
        }

        worldToScreen(worldX, worldY) {
          const effectiveCellSize = this.CELL_SIZE * this.zoom;
          const centerX = this.canvas.width / 2;
          const centerY = this.canvas.height / 2;

          const screenX =
            (worldX - this.viewportX) * effectiveCellSize + centerX;
          const screenY =
            (worldY - this.viewportY) * effectiveCellSize + centerY;

          return [screenX, screenY];
        }

        toggleCell(x, y) {
          const key = `${x},${y}`;

          if (this.isMouseDown && this.lastToggledCell === key) {
            return;
          }

          this.lastToggledCell = key;

          if (this.hasCell(x, y)) {
            this.removeCell(x, y);
          } else {
            this.addCell(x, y);
          }
          this.updateHUD();
        }

        // Shape patterns (same as before)
        getShapePattern(shapeName) {
          const patterns = {
            block: [
              [0, 0],
              [1, 0],
              [0, 1],
              [1, 1],
            ],
            blinker: [
              [0, 0],
              [1, 0],
              [2, 0],
            ],
            glider: [
              [1, 0],
              [2, 1],
              [0, 2],
              [1, 2],
              [2, 2],
            ],
            beacon: [
              [0, 0],
              [1, 0],
              [0, 1],
              [2, 3],
              [3, 2],
              [3, 3],
            ],
            toad: [
              [1, 0],
              [2, 0],
              [3, 0],
              [0, 1],
              [1, 1],
              [2, 1],
            ],
            pulsar: [
              [2, 0],
              [3, 0],
              [4, 0],
              [8, 0],
              [9, 0],
              [10, 0],
              [0, 2],
              [5, 2],
              [7, 2],
              [12, 2],
              [0, 3],
              [5, 3],
              [7, 3],
              [12, 3],
              [0, 4],
              [5, 4],
              [7, 4],
              [12, 4],
              [2, 5],
              [3, 5],
              [4, 5],
              [8, 5],
              [9, 5],
              [10, 5],
              [2, 7],
              [3, 7],
              [4, 7],
              [8, 7],
              [9, 7],
              [10, 7],
              [0, 8],
              [5, 8],
              [7, 8],
              [12, 8],
              [0, 9],
              [5, 9],
              [7, 9],
              [12, 9],
              [0, 10],
              [5, 10],
              [7, 10],
              [12, 10],
              [2, 12],
              [3, 12],
              [4, 12],
              [8, 12],
              [9, 12],
              [10, 12],
            ],
          };

          return patterns[shapeName] || [];
        }

        async placeShape(centerX, centerY, shapeName) {
          if (shapeName === "clear") {
            this.chunks.clear();
            if (this.isConnected) {
              await this.convexClient.mutation("gameOfLife:clearWorld");
            }
            this.updateHUD();
            this.render();
            return;
          }

          const pattern = this.getShapePattern(shapeName);
          if (pattern.length === 0) return;

          const minX = Math.min(...pattern.map(([x, y]) => x));
          const maxX = Math.max(...pattern.map(([x, y]) => x));
          const minY = Math.min(...pattern.map(([x, y]) => y));
          const maxY = Math.max(...pattern.map(([x, y]) => y));

          const offsetX = Math.floor((maxX + minX) / 2);
          const offsetY = Math.floor((maxY + minY) / 2);

          for (const [px, py] of pattern) {
            const worldX = centerX + px - offsetX;
            const worldY = centerY + py - offsetY;
            this.addCell(worldX, worldY);
          }

          this.updateHUD();
          this.render();
        }

        // Event handlers (same pattern as before but without local game loop)
        setupEventListeners() {
          this.canvas.addEventListener("mousedown", (e) =>
            this.handleMouseDown(e),
          );
          this.canvas.addEventListener("mousemove", (e) =>
            this.handleMouseMove(e),
          );
          this.canvas.addEventListener("wheel", (e) => this.handleWheel(e), {
            passive: false,
          });

          document.addEventListener("mouseup", (e) => this.handleMouseUp(e));
          document.addEventListener("mousemove", (e) =>
            this.handleGlobalMouseMove(e),
          );
          document.addEventListener("keydown", (e) => this.handleKeyDown(e));
          document.addEventListener("keyup", (e) => this.handleKeyUp(e));

          // Shape buttons
          document.querySelectorAll(".shape-button").forEach((button) => {
            button.addEventListener("click", (e) => {
              document
                .querySelectorAll(".shape-button")
                .forEach((b) => b.classList.remove("selected"));
              e.target.classList.add("selected");
              this.selectedShape = e.target.dataset.shape;
            });
          });

          window.addEventListener("resize", () => {
            this.setupCanvas();
            this.render();
          });

          this.canvas.addEventListener("contextmenu", (e) =>
            e.preventDefault(),
          );
        }

        handleMouseDown(e) {
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          this.isMouseDown = true;

          if (e.shiftKey || this.isShiftPressed) {
            this.isPanning = true;
            this.canvas.classList.add("panning");
            this.dragStart = {
              x: e.clientX,
              y: e.clientY,
              viewportX: this.viewportX,
              viewportY: this.viewportY,
            };
          } else {
            const [worldX, worldY] = this.screenToWorld(mouseX, mouseY);

            if (this.selectedShape === "draw") {
              this.lastToggledCell = "";
              this.toggleCell(worldX, worldY);
              this.render();
            } else {
              this.placeShape(worldX, worldY, this.selectedShape);
            }
          }
        }

        handleMouseMove(e) {
          if (
            !this.isMouseDown ||
            this.isPanning ||
            this.selectedShape !== "draw"
          )
            return;

          const now = performance.now();
          if (now - this.lastDragUpdate < this.DRAG_THROTTLE_MS) {
            return;
          }
          this.lastDragUpdate = now;

          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          const [worldX, worldY] = this.screenToWorld(mouseX, mouseY);

          this.toggleCell(worldX, worldY);
          this.render();
        }

        handleGlobalMouseMove(e) {
          if (this.isPanning) {
            const now = performance.now();
            if (now - this.lastDragUpdate < this.DRAG_THROTTLE_MS) {
              return;
            }
            this.lastDragUpdate = now;

            const dx = e.clientX - this.dragStart.x;
            const dy = e.clientY - this.dragStart.y;

            const effectiveCellSize = this.CELL_SIZE * this.zoom;
            const worldDx = -dx / effectiveCellSize;
            const worldDy = -dy / effectiveCellSize;

            this.viewportX = this.dragStart.viewportX + worldDx;
            this.viewportY = this.dragStart.viewportY + worldDy;

            this.updateHUD();
            this.render();
          }

          if (this.isShiftPressed && !this.isPanning) {
            this.canvas.classList.add("pan-ready");
          } else if (!this.isPanning) {
            this.canvas.classList.remove("pan-ready");
          }
        }

        handleMouseUp(e) {
          this.isMouseDown = false;
          this.isPanning = false;
          this.lastToggledCell = "";
          this.lastDragUpdate = 0;
          this.canvas.classList.remove("panning", "pan-ready");

          if (this.isShiftPressed) {
            this.canvas.classList.add("pan-ready");
          }

          if (this.isConnected) {
            this.loadVisibleChunks();
          }
        }

        handleWheel(e) {
          e.preventDefault();

          const zoomFactor = 1.2;
          const newZoom =
            e.deltaY < 0
              ? Math.min(this.zoom * zoomFactor, this.maxZoom)
              : Math.max(this.zoom / zoomFactor, this.minZoom);

          this.zoom = newZoom;
          this.updateHUD();
          this.render();

          if (this.isConnected) {
            this.loadVisibleChunks();
          }
        }

        handleKeyDown(e) {
          const MOVE_SPEED = 5 / this.zoom;

          if (e.key === "Shift") {
            this.isShiftPressed = true;
            if (!this.isPanning) {
              this.canvas.classList.add("pan-ready");
            }
          }

          switch (e.key.toLowerCase()) {
            case "w":
            case "arrowup":
              this.viewportY -= MOVE_SPEED;
              this.updateHUD();
              this.render();
              e.preventDefault();
              break;
            case "s":
            case "arrowdown":
              this.viewportY += MOVE_SPEED;
              this.updateHUD();
              this.render();
              e.preventDefault();
              break;
            case "a":
            case "arrowleft":
              this.viewportX -= MOVE_SPEED;
              this.updateHUD();
              this.render();
              e.preventDefault();
              break;
            case "d":
            case "arrowright":
              this.viewportX += MOVE_SPEED;
              this.updateHUD();
              this.render();
              e.preventDefault();
              break;
            case " ":
              e.preventDefault();
              this.toggleSimulation();
              break;
            case "c":
              e.preventDefault();
              this.placeShape(0, 0, "clear");
              break;
          }
        }

        handleKeyUp(e) {
          if (e.key === "Shift") {
            this.isShiftPressed = false;
            this.canvas.classList.remove("pan-ready");

            if (this.isPanning) {
              this.isPanning = false;
              this.canvas.classList.remove("panning");
            }
          }
        }

        async toggleSimulation() {
          if (!this.isConnected) return;

          try {
            const newState = await this.convexClient.mutation(
              "gameOfLife:toggleSimulation",
            );
            console.log("Simulation toggled:", newState);
          } catch (error) {
            console.error("Failed to toggle simulation:", error);
          }
        }

        // Get visible chunks for rendering
        getVisibleChunks() {
          const effectiveCellSize = this.CELL_SIZE * this.zoom;
          const centerX = this.canvas.width / 2;
          const centerY = this.canvas.height / 2;

          const leftBound = this.viewportX - centerX / effectiveCellSize;
          const rightBound = this.viewportX + centerX / effectiveCellSize;
          const topBound = this.viewportY - centerY / effectiveCellSize;
          const bottomBound = this.viewportY + centerY / effectiveCellSize;

          const minChunkX = Math.floor(leftBound / this.CHUNK_SIZE);
          const maxChunkX = Math.floor(rightBound / this.CHUNK_SIZE);
          const minChunkY = Math.floor(topBound / this.CHUNK_SIZE);
          const maxChunkY = Math.floor(bottomBound / this.CHUNK_SIZE);

          const visibleChunks = [];
          for (let chunkX = minChunkX; chunkX <= maxChunkX; chunkX++) {
            for (let chunkY = minChunkY; chunkY <= maxChunkY; chunkY++) {
              const chunkKey = `${chunkX},${chunkY}`;
              const chunk = this.chunks.get(chunkKey);
              if (chunk && chunk.size > 0) {
                visibleChunks.push({
                  chunkX,
                  chunkY,
                  chunkKey,
                  chunk,
                });
              }
            }
          }

          return visibleChunks;
        }

        render() {
          const effectiveCellSize = this.CELL_SIZE * this.zoom;

          this.ctx.fillStyle = "#ffffff";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          const centerX = this.canvas.width / 2;
          const centerY = this.canvas.height / 2;

          const leftBound = this.viewportX - centerX / effectiveCellSize;
          const rightBound = this.viewportX + centerX / effectiveCellSize;
          const topBound = this.viewportY - centerY / effectiveCellSize;
          const bottomBound = this.viewportY + centerY / effectiveCellSize;

          // Draw grid if zoomed in enough
          if (this.zoom > 0.5) {
            this.ctx.strokeStyle = "#e5e7eb";
            this.ctx.lineWidth = Math.max(0.5, this.zoom * 0.5);

            const startX = Math.floor(leftBound);
            const endX = Math.ceil(rightBound);
            const startY = Math.floor(topBound);
            const endY = Math.ceil(bottomBound);

            // Draw vertical grid lines
            for (let x = startX; x <= endX; x++) {
              const [screenX] = this.worldToScreen(x, 0);
              if (
                screenX >= -effectiveCellSize &&
                screenX <= this.canvas.width + effectiveCellSize
              ) {
                this.ctx.beginPath();
                this.ctx.moveTo(screenX, 0);
                this.ctx.lineTo(screenX, this.canvas.height);
                this.ctx.stroke();
              }
            }

            // Draw horizontal grid lines
            for (let y = startY; y <= endY; y++) {
              const [, screenY] = this.worldToScreen(0, y);
              if (
                screenY >= -effectiveCellSize &&
                screenY <= this.canvas.height + effectiveCellSize
              ) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, screenY);
                this.ctx.lineTo(this.canvas.width, screenY);
                this.ctx.stroke();
              }
            }
          }

          // Draw alive cells from visible chunks only
          this.ctx.fillStyle = "#000000";
          let visibleCells = 0;

          const visibleChunks = this.getVisibleChunks();

          for (const { chunkX, chunkY, chunk } of visibleChunks) {
            for (const packed of chunk) {
              const [localX, localY] = this.unpackCoords(packed);
              const worldX = chunkX * this.CHUNK_SIZE + localX;
              const worldY = chunkY * this.CHUNK_SIZE + localY;

              if (
                worldX >= leftBound &&
                worldX <= rightBound &&
                worldY >= topBound &&
                worldY <= bottomBound
              ) {
                const [screenX, screenY] = this.worldToScreen(worldX, worldY);

                if (
                  screenX >= -effectiveCellSize &&
                  screenX <= this.canvas.width + effectiveCellSize &&
                  screenY >= -effectiveCellSize &&
                  screenY <= this.canvas.height + effectiveCellSize
                ) {
                  this.ctx.fillRect(
                    screenX + 1,
                    screenY + 1,
                    effectiveCellSize - 1,
                    effectiveCellSize - 1,
                  );
                  visibleCells++;
                }
              }
            }
          }

          document.getElementById("visibleCells").textContent = visibleCells;
        }

        startPerformanceMonitoring() {
          const trackPerformance = () => {
            this.frameCount++;
            const now = performance.now();

            if (now - this.lastFpsTime >= 1000) {
              this.fps = this.frameCount;
              this.frameCount = 0;
              this.lastFpsTime = now;
              this.updatePerformanceHUD();
            }

            this.rafId = requestAnimationFrame(trackPerformance);
          };

          trackPerformance();
        }

        updatePerformanceHUD() {
          document.getElementById("fps").textContent = this.fps;

          if (performance.memory) {
            const memoryMB = Math.round(
              performance.memory.usedJSHeapSize / 1024 / 1024,
            );
            document.getElementById("memory").textContent = `${memoryMB}MB`;
            document.getElementById("memory").style.color = "#3b82f6";
          } else {
            document.getElementById("memory").textContent = "N/A";
            document.getElementById("memory").style.color = "#6b7280";
          }
        }

        updateHUD() {
          document.getElementById("generation").textContent = this.generation;
          document.getElementById("totalChunks").textContent = this.chunks.size;
          document.getElementById("zoom").textContent = this.zoom.toFixed(1);
          document.getElementById("viewportX").textContent =
            Math.round(this.viewportX * 10) / 10;
          document.getElementById("viewportY").textContent =
            Math.round(this.viewportY * 10) / 10;
          document.getElementById("status").textContent = this.isRunning
            ? "RUNNING"
            : "STOPPED";
          document.getElementById("status").style.color = this.isRunning
            ? "#059669"
            : "#6b7280";

          this.updatePerformanceHUD();
        }

        cleanup() {
          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }

          if (this.syncInterval) {
            clearInterval(this.syncInterval);
            this.syncInterval = null;
          }

          if (this.convexClient) {
            this.convexClient.close();
          }
        }
      }

      // Initialize the game
      const game = new ServerTickGameOfLife();

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        game.cleanup();
      });
    </script>
  </body>
</html>
